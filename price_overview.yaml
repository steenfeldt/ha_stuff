type: custom:button-card
name: Prisoversigt
show_icon: false
show_name: false
styles:
  card:
    - background: rgba(0,0,0,0.2)
    - border-radius: 12px
    - padding: 15px
  name:
    - font-size: 1.1em
    - font-weight: 500
    - margin-bottom: 10px
    - padding: 0
  grid:
    - grid-template-areas: "\"n\" \"current\" \"chart\""
    - grid-template-rows: auto auto 1fr
    - padding: 0
  custom_fields:
    current:
      - margin-bottom: 15px
    chart:
      - width: 100%
custom_fields:
  current: |
    [[[
      const today = entity.attributes.raw_today;
      const currentPrice = parseFloat(entity.state);
      if (!today) return '<div>No data</div>';
      
      const currentHour = new Date().getHours();
      
      // Group by hour and calculate averages
      const hourlyData = {};
      today.forEach(entry => {
        const hour = new Date(entry.hour).getHours();
        if (!hourlyData[hour]) {
          hourlyData[hour] = [];
        }
        hourlyData[hour].push(entry.price);
      });
      
      const hourlyAverages = [];
      for (let h = 0; h < 24; h++) {
        if (hourlyData[h]) {
          const avg = hourlyData[h].reduce((a,b) => a+b, 0) / hourlyData[h].length;
          hourlyAverages.push({hour: h, price: avg});
        }
      }
      
      const allPrices = hourlyAverages.map(e => e.price);
      const maxAllPrice = Math.max(...allPrices);
      const minAllPrice = Math.min(...allPrices);
      const priceRange = maxAllPrice - minAllPrice;
      
      let textColor;
      if (currentPrice < 1.5) textColor = '#2ecc71';
      else if (currentPrice < 2.0) textColor = '#f1c40f';
      else if (currentPrice < 2.5) textColor = '#f39c12';
      else textColor = '#e74c3c';
      
      let graph = '<div style="display: flex; align-items: flex-end; gap: 2px; height: 60px; margin-bottom: 8px;">';
      
      hourlyAverages.forEach((entry) => {
        const height = ((entry.price - minAllPrice) / priceRange * 100).toFixed(1);
        const isCurrent = entry.hour === currentHour;
        
        let color;
        if (entry.price < 1.5) color = 'rgba(46, 204, 113, 0.7)';
        else if (entry.price < 2.0) color = 'rgba(241, 196, 15, 0.7)';
        else if (entry.price < 2.5) color = 'rgba(243, 156, 18, 0.7)';
        else color = 'rgba(231, 76, 60, 0.7)';
        
        const border = isCurrent ? 'border: 2px solid white; box-shadow: 0 0 8px rgba(255,255,255,0.6);' : '';
        
        graph += `<div style="flex: 1; height: ${height}%; background: ${color}; border-radius: 2px 2px 0 0; ${border}"></div>`;
      });
      
      graph += '</div>';
      
      return `
        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px;">
          ${graph}
          <div style="text-align: center;">
            <div style="font-size: 1.4em; font-weight: bold; color: ${textColor};">${currentPrice.toFixed(2)} kr/kWh</div>
          </div>
        </div>
      `;
    ]]]
  chart: |
    [[[
      const today = entity.attributes.raw_today;
      const tomorrow = entity.attributes.raw_tomorrow;
      if (!today) return '<div>No data</div>';
      
      const currentHour = new Date().getHours();
      const now = new Date();
      
      // Combine today and tomorrow data
      const allData = [...today];
      if (tomorrow) {
        allData.push(...tomorrow);
      }
      
      // Define all possible periods
      const periodDefinitions = [
        {name: 'Night', icon: 'üåô', start: 0, end: 5, hours: '00-05'},
        {name: 'Morning', icon: '‚òÄÔ∏è', start: 5, end: 12, hours: '05-12'},
        {name: 'Afternoon', icon: '‚õÖ', start: 12, end: 17, hours: '12-17'},
        {name: 'Dinner', icon: 'üçΩÔ∏è', start: 17, end: 19, hours: '17-19'},
        {name: 'Evening', icon: 'üåÖ', start: 19, end: 24, hours: '19-24'}
      ];
      
      // Find next 24 hours of periods starting from current hour
      const upcomingPeriods = [];
      let hoursChecked = 0;
      let dayOffset = 0;
      
      while (hoursChecked < 24 && upcomingPeriods.length < 6) {
        const checkHour = (currentHour + hoursChecked) % 24;
        
        // If we wrapped around to next day
        if (checkHour < currentHour && dayOffset === 0) {
          dayOffset = 1;
        }
        
        // Find which period this hour belongs to
        for (let def of periodDefinitions) {
          if (checkHour >= def.start && checkHour < def.end) {
            // Check if we already have this period
            const periodKey = `${def.name}-${dayOffset}`;
            if (!upcomingPeriods.find(p => p.key === periodKey)) {
              const isToday = dayOffset === 0;
              const periodData = isToday ? today : tomorrow;
              
              upcomingPeriods.push({
                ...def,
                key: periodKey,
                data: periodData,
                dayOffset: dayOffset,
                label: dayOffset === 0 ? def.name : `${def.name} (i morgen)`
              });
            }
            break;
          }
        }
        
        hoursChecked++;
      }
      
      // Calculate stats for each period
      let maxPrice = 0;
      const periodData = upcomingPeriods.map((period, index) => {
        if (!period.data) return {...period, avg: 0, min: 0, max: 0, noData: true, isCurrent: false};
        
        const prices = period.data.filter(e => {
          const hour = new Date(e.hour).getHours();
          return hour >= period.start && hour < period.end;
        }).map(e => e.price);
        
        if (prices.length === 0) return {...period, avg: 0, min: 0, max: 0, noData: true, isCurrent: false};
        
        const avg = prices.reduce((a,b) => a+b, 0) / prices.length;
        const min = Math.min(...prices);
        const max = Math.max(...prices);
        if (avg > maxPrice) maxPrice = avg;
        
        // First period is always current
        const isCurrent = index === 0;
        
        return {...period, avg, min, max, noData: false, isCurrent};
      });
      
      let output = '';
      periodData.forEach(pd => {
        if (pd.noData) {
          output += `
            <div style="margin: 10px 0;">
              <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.9em;">
                <span>${pd.icon} ${pd.label} <span style="color: rgba(255,255,255,0.6); font-size: 0.85em;">(${pd.hours})</span></span>
                <span style="font-weight: 600; color: rgba(255,255,255,0.4);">-</span>
              </div>
              <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 20px; position: relative;">
                <div style="background: rgba(100,100,100,0.3); border-radius: 4px; height: 100%; width: 100%; display: flex; align-items: center; justify-content: center; font-size: 0.75em;">
                  Ingen data endnu
                </div>
              </div>
            </div>
          `;
          return;
        }
        
        const width = (pd.avg / maxPrice * 100).toFixed(1);
        let color;
        if (pd.avg < 1.5) color = 'rgba(46, 204, 113, 0.8)';
        else if (pd.avg < 2.0) color = 'rgba(241, 196, 15, 0.8)';
        else if (pd.avg < 2.5) color = 'rgba(243, 156, 18, 0.8)';
        else color = 'rgba(231, 76, 60, 0.8)';
        
        const highlight = pd.isCurrent ? 'border: 2px solid white; box-shadow: 0 0 10px rgba(255,255,255,0.4);' : '';
        
        output += `
          <div style="margin: 10px 0;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.9em;">
              <span>${pd.icon} ${pd.label} <span style="color: rgba(255,255,255,0.6); font-size: 0.85em;">(${pd.hours})</span></span>
              <span style="font-weight: 600;">${pd.avg.toFixed(2)} kr</span>
            </div>
            <div style="background: rgba(255,255,255,0.1); border-radius: 4px; height: 20px; position: relative; ${highlight}">
              <div style="background: ${color}; border-radius: 4px; height: 100%; width: ${width}%; display: flex; align-items: center; padding-left: 8px; font-size: 0.75em; font-weight: 500;">
                ${pd.min.toFixed(2)}-${pd.max.toFixed(2)}
              </div>
            </div>
          </div>
        `;
      });
      
      return output;
    ]]]
entity: sensor.elpriser
